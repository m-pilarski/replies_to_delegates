---
output: github_document
editor_options: 
  chunk_output_type: inline
---

```{r, include = FALSE}

knitr::opts_chunk$set(
  collapse=TRUE,
  comment="#>",
  out.width="100%"
)

options(
  tibble.print_min=5, 
  tibble.print_max=5,
  width=80
)

```

# get_replies_delegates

## Overview


Scripts that can be used to collect all Twitter coversations started by members of the US congress. The replies are collected via the [standard search (Version 1.1)](https://developer.twitter.com/en/docs/twitter-api/v1/tweets/search/api-reference/get-search-tweets) API endpoint. As my access to historical data through this API enpoint is limited to the past ~7 days, the script has to be executed repeatedly.


## Repeated Data Collection


01. [get_tweets_raw](https://github.com/m-pilarski/replies_to_delegates/blob/master/01.01-get_tweets_raw.R)
    - replies are collected via the [standard search (Version 1.1)](https://developer.twitter.com/en/docs/twitter-api/v1/tweets/search/api-reference/get-search-tweets) API endpoint
    - the collected tweets are stored in a SQLite Database


## Exemplary results


```{r, message=FALSE}

library(tidyverse)
library(DBI)

dir_data <- "~/Documents/get_tweets/data"

tweets_db <- dbConnect(
  drv=RSQLite::SQLite(), 
  dbname=fs::path(dir_data, "tweets", ext="db"),
  extended_types=TRUE
)

dbListTables(tweets_db)

```


```{r}

tbl(tweets_db, "tweets_raw")

# Number of rows
pull(tally(tbl(tweets_db, "tweets_raw")), n)

```


```{r, fig.height=5, fig.width=8}

tweets_count <- local({
  
  .tweets_count_chunk_size <- 1e6L
  
  .tweets_count_statement <- str_c(
    "SELECT `tweet_convers_user_screen_name`, `tweet_created_at` ",
    "FROM `tweets_raw`"
  )
  
  .tweets_count <- tibble()
  
  .tweets_count_query <- DBI::dbSendQuery(
    conn=tweets_db, statement=.tweets_count_statement
  )
  
  repeat{
    
    .chunk_raw <- dbFetch(res=.tweets_count_query, n=.tweets_count_chunk_size)
    
    if(nrow(.chunk_raw) == 0){break()}
    
    .tweets_count <- 
      .chunk_raw %>% 
      count(
        tweet_convers_user_screen_name,
        tweet_created_at_day = lubridate::as_date(tweet_created_at), 
        name="count"
      ) %>% 
      bind_rows(.tweets_count) %>% 
      group_by(across(-count)) %>% 
      summarize(across(count, sum), .groups="drop")
    
    gc()
    
  }
  
  dbClearResult(.tweets_count_query)
  
  .delegates_info <- 
    tbl(tweets_db, "delegates_info") %>% 
    select(
      tweet_convers_user_screen_name, 
      tweet_convers_user_party = party,
      tweet_convers_user_role = role
    ) %>% 
    collect()
  
  .tweets_count <- left_join(
    .tweets_count, .delegates_info, by="tweet_convers_user_screen_name"
  )
  
  return(.tweets_count)
  
})

tweets_count %>% 
  group_by(tweet_convers_user_party, tweet_created_at_day) %>% 
  summarise(across(count, sum), .groups="drop") %>% 
  mutate(count = modify_if(
    as.double(count), tweet_convers_user_party != "democrat", `*`, -1
  )) %>% 
  filter(tweet_created_at_day > lubridate::ymd("2022-06-01")) %>% 
  ggplot(
    aes(x=tweet_created_at_day, y=count, fill=tweet_convers_user_party)
  ) + 
  geom_col(width=1) +
  scale_y_continuous(
    labels=function(.b){scales::number(abs(.b))},
    limits=function(.l){.m <- max(abs(.l)); c(-.m, .m)}
  ) +
  rcartocolor::scale_fill_carto_d(palette="Safe") +
  theme(legend.position="bottom")

```


